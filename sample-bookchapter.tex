%
% Sample SBC book chapter
%
% This is a public-domain file.
%
% Charset: ISO8859-1 (latin-1) áéíóúç
%
\documentclass{SBCbookchapter}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazilian,english]{babel}
\usepackage{graphicx}
\usepackage[pdftex]{hyperref} % para links e afins!
\usepackage{listings} % para utilização de código e highlight

\usepackage{listings-golang} % import this package after listings
\usepackage{color}
\lstset{ % add your own preferences
	basicstyle=\ttfamily,
    frame=l,
    keywordstyle=\color{red},
    numbers=left,
    numbersep=10pt,
    showstringspaces=false, 
    stringstyle=\color{blue},
    tabsize=4,
    language=Golang % this is it 
}


\author{Diego F. Sousa, Leonardo A. G. Silva}
\title{Uma Introdução ao Go: A Linguagem Performática do Google}

\begin{document}
\maketitle

\begin{abstract}
Over time, software development has been improving and the tools used for its composition evolve according to the needs that the technology tends to solve. We can then define Programming Languages as the main artifact of this medium because it is the intermediate where the computer processes information in order to generate outputs for beneficial use. In this scenario, the Go programming language has become a viable alternative for the development of applications focused on high performance without losing readability and simplicity. The sections in this chapter introduce language to its concepts and aspects of greater relevance.
\end{abstract}

\begin{resumo}
\begin{otherlanguage}{brazilian}
Ao longo do tempo, o desenvolvimento de \textit{software} foi se aprimorando e as ferramentas utilizadas para sua composição evoluindo de acordo com as necessidades que a tecnologia tende a resolver. Podemos então definir as Linguagens de Programação como o principal artefato deste meio por ser o intermédio onde computador processa informações a fim de gerar saídas para o uso benéfico. Neste panorama, a linguagem de programação Go tem se tornado uma alternativa viável para o desenvolvimento de aplicações com foco em alta performance sem perder legibilidade e simplicidade. As seções deste capítulo introduzem a linguagem quanto aos seus conceitos e aspectos de maior relevância.
\end{otherlanguage}
\end{resumo}

\section{Introdução}


O ato de criar um novo \textit{software} pode requerer paciência, atenção e proatividade por parte do desenvolvedor e, devido à isso, as Linguagens de Programação estão sempre se renovando e buscando a maior proximidade com o programador tornando-se mais portáveis. O maior exemplo disso são as linguagens rotuladas como de alto nível, das quais podemos citar Python, PHP, Ruby, C++, Java, entre outras.

As linguagens de alto nível tem como característica principal o poder elevado de abstração aproximando sua sintaxe à linguagem humana, diferentemente das linguagens de baixo nível, que por sua vez se assemelham ao código utilizado por máquina \cite{se}. \textit{Golang} -- como também é abreviada -- fica entre as linguagens de alto nível, assim como colabora para facilitar o desenvolvimento sem perder o alto desempenho \cite{fi}. %A quantificação de seu desempenho é notado pelo poder de execução de suas \textit{threads}, melhor explicadas na seção \ref{concorrencia}. 

As próximas seções deste capítulo detalham a linguagem desde seus conceitos principais, passando pela instalação, preparação do ambiente e sintaxe básica. Alguns elementos exclusivos da linguagem serão apresentados com devido foco ao decorrer das seções.

\subsection{Um pouco sobre Go}

O problema do longo tempo de processamento recorrente em boa parte das Linguagens de Programação atuais foi um dos principais motivos para a criação de \textit{Golang} \cite{marins}. Os grandes servidores da Google necessitavam de um grande poder de eficiência e produtividade para tornar aplicações escaláveis e mais rápidas. Assim sendo, em novembro de 2009 deu-se inicio a linguagem  Go dentro das dependências dos escritórios da Google. Seu projeto de criação foi liderado por Rob Pike, Ken Thompson e Robert Griessemer \cite{patel}.

Uma das principais vantagens da linguagem está no poder de processamento que permite aplicações trabalharem aproveitando o máximo do poder dos processadores \textit{multi-core} de forma mais otimizada \cite{young}. %Além de ser baseda em C com caracteristicas de tipagem forte e estática, alto nivel, \textit{structs} e \textit{garbage collection}. 
Tal poder de processamento é oriundo das \textit{goroutines}, que são rotinas que se comunicam por \textit{channels}, evitando, tanto o uso de memória compartilhada, como técnicas de sincronizações mais pesadas tal como "semáforos".


O Go, embora seja recente, dá suporte a várias bibliotecas para a criação de ferramentas de comunicação em rede, servidores HTTP, expressões regulares e leitura/escrita de arquivos. Por ser robusta exige um certo nível de atenção na sua codificação, característica que permite os desenvolvedores produzirem códigos mais limpos e padronizados \cite{doxsey}. No mercado atual Go já possui seu espaço, principalmente como uma possível sucessora da linguagem C por suportar a demanda de trabalho em servidores e sistemas \textit{multi-thread} \cite{codal}. %Além de ser uma mais usadas e divulgada pela Google, expandindo-se ainda mais pela a força do nome de uma das maiores empresas multinacional do mundo. 

\subsection{Go atualmente}

Devido seu diferencial, Golang está em plena ascenção. O reflexo de seu crescimento é representado pela sua utilização nos dias atuais, tanto por empresas internacionais como nacionais. Além da própria Google, outras companhias usam Go em suas infraestruturas, estando entre elas: Adobe, BBC, Canonical, Dell, DigitalOcean, Dropbox, Facebook, IBM, Mozilla, SoundCloud, Twitter, Yahoo, entre outras.

No Brasil não é diferente, muitas companhias estão aderindo ao Go. Entre as empresas e instituições com maior respaldo estão: Globo.com, Magazine Luiza, Mercado Livre, Dafiti, PagSeguro, Pagar.me, Jusbrasil, Hotel Urbano, Walmart, Nuveo, Nic.br, entre outras. A lista completa de companhias que usam Go pelo mundo está no repositório oficial da linguagem no GitHub\footnote{\url{https://github.com/golang/go/wiki/GoUsers}}.

\section{Instalando e configurando o Go}

Para começar a programar na linguagem Go, além de ser necessário que seja feito o \textit{download} e instalação, é fundamental preparar do ambiente consistindo em modificar algumas de suas variáveis. Devem ser adicionadas três novas variáveis ao sistema. Todos os projetos criados em Go devem estar na pasta apontada pelo \texttt{GOPATH}\footnote{Diretório configurado para o desenvolvimento de aplicações em Go na máquina do usuário.}. As subseções abaixo apresentam o passo a passo para instalação em sistemas Linux e Windows.

\subsection{Linux}

Para efetuar a instalação no ambiente Linux, basta ir até o site oficial da linguagem na seção de \textit{downloads}\footnote{\label{note1}\url{https://golang.org/dl/}} e escolher a opção \textbf{Linux}. Após fazer o \textit{download}, navegue pelo terminal até a pasta onde está o arquivo compactado e descompacte-o com o comando \texttt{sudo tar -zxvf "nome\_do\_arquivo".tar.gz}. Com a extração concluída, mova o arquivo para o diretório \texttt{/usr/local} com o comando \texttt{sudo mv go /usr/local}.

Agora edite o arquivo \texttt{/etc/profile} adicionando as variáveis de ambiente para o Go:

\noindent\texttt{export GOPATH=\$HOME/GO}\\
\texttt{export GOROOT=/usr/local/go}\\
\texttt{export PATH=\$PATH:\$GOROOT/bin:\$GOPATH/bin}

É necessário criar uma pasta dentro do diretório \texttt{\$HOME}\footnote{Para descobrir onde fica o diretório \texttt{\$HOME} execute o comando \texttt{echo \$HOME} no terminal.} com o nome "GO" de acordo com a variável de ambiente descrita em \texttt{GOPATH} e executar o comando \texttt{source /etc/profile} para finalizar a instalação. O próximo passo é estender a pasta \texttt{\$GOPATH} criando as pastas \textbf{pkg}, \textbf{bin} e \textbf{src}. Preferencialmente crie seus programas dentro do diretório \texttt{\$GOPATH/src}.

Por último, verifique a instalação executando o comando \texttt{go version}. O retorno deve ser algo como:

\noindent\texttt{go version go1.8.3 linux/amd64}


\subsection{Windows}

Para o Windows, o \textit{download} do Go pode ser feito através do mesmo \textit{link}\textsuperscript{\ref{note1}}. Selecione a opção Windows e faça o \textit{download}. No ato da instalação é importante que os arquivos sejam inseridos no diretório \texttt{C:\char`\\Go}. Feita a instalação, é necessário configurar as variáveis de ambiente. No Windows é possível encontrá-la em dois lugares:

\begin{itemize}
	\item "Painel de Controle" $\rightarrow$ "Sistema" $\rightarrow$ "Avançado" $\rightarrow$ "Variáveis de ambiente";
	\item "Configurações avançadas do sistema" $\rightarrow$ "Variáveis de ambiente".
\end{itemize}

Na maioria dos casos a variável \texttt{GOROOT} já está automaticamente adicionada. Caso contrário você deve adicioná-la apontando-a para o diretório \texttt{C:\char`\\Go}. Crie uma pasta contendo as pastas \textbf{bin}, \textbf{pkg} e \textbf{src} para ser seu diretório de trabalho e adicione mais duas variáveis: \texttt{PATH} para o caminho \texttt{C:\char`\\Go\char`\\bin} e a varíavel \texttt{GOPATH} direcionada para seu diretório de trabalho.

Desenvolva seus programas sempre dentro da pasta \texttt{\$GOPATH/src}. Por último visualize sua instalação usando \texttt{go version} no Prompt de Comando ou CMD. A saída deve ser essa:

\noindent\texttt{go version go1.8.3 windows/amd64}

\section{Estrutura básica e sintaxe}

Após a instalação e configuração já podemos criar nossos primeiros programas. Nesta seção serão apresentados elementos que constituem a sintaxe básica de Go. Programas em Go podem ser desenvolvidos em qualquer editor de texto que dê suporte a codificação \texttt{UTF-8}. Todos os exemplos mostrados nas próximas seções tem foco na execução em ambiente Linux.

\subsection{Hello World}

Para o primeiro contato com a linguagem, podemos iniciar com um tradicional \textit{Hello, World}. Portanto, salve um arquivo com título de sua preferência -- sugerimos \texttt{hello.go} -- dentro da pasta \texttt{src} do diretório apontado pelo \texttt{\$GOPATH} com o seguinte conteúdo:

\begin{lstlisting}
package main

import "fmt"

func main() {
    fmt.Println("Hello World!")
}
\end{lstlisting}

Para compilar o código acima, basta executar \texttt{go run hello.go}. A saída para este programa será:

\texttt{Hello World}

Neste primeiro exemplo pode-se notar algumas caraterísticas da linguagem. A primeira delas é que Go não possui ponto-e-vírgula ou quaisquer ponto e acentuações ao final das instruções, diferentemente de linguagens como C ou Java. Outra característica é que todo código em Go é dividido em três seções principais: 

\begin{enumerate}
	\item \textbf{Declaração do pacote}: Todo arquivo Go deve existir dentro de um pacote. Se o pacote for o ponto de partida do projeto, deve ser chamado de \textit{main} e deve conter a função \textit{main} -- \texttt{func main()} --. A declaração do pacote deve estar no início do código;
	\item \textbf{Declaração de dependências}: A segunda seção é destinada as dependências de um programa em Go, podendo elas serem opcionais. No nosso exemplo, usamos o \texttt{fmt} para auxiliar na entrada e saída de dados pelo terminal;
	\item \textbf{Código}: Por último, temos o código de fato. Nele é onde aplicamos a lógica e é a parte central de um programa em Go.
\end{enumerate}

A função \textit{main} de um programa em Go não recebe parâmetros e nem retorna valores, mais uma característica que a difere de linguagens como o Java ou C.
Para comando de entrada e saída podemos usar as funções provenientes do pacote \texttt{fmt}. O \texttt{fmt.Println()} imprime o conteúdo seguido de quebra de linha, enquanto que \texttt{fmt.P\\rint()} imprime apenas o conteúdo. Abordamos isso melhor na seção \ref{secaodeio}.

\subsection{Variáveis}

Go tem tipagem forte e estática, isso quer dizer que o tipo das variáveis declaradas durante a execução de um programa não podem ser alterados. Apesar deste conjunto de características, Go traz em sua sintaxe uma forma de declaração limpa, o que facilita e torna rapido o desenvolvimento das aplicações. A declaração de variáveis em Go pode ser feita de quatro maneiras principais, como apresenta o código abaixo:

\begin{lstlisting}
package main

import "fmt"

func main() {
	var variavel_a int // tipo 1
	variavel_b := 5 // tipo 2
	
	var variavel_c int = 45 // tipo 3
	var x, y int = 1, 2 //tipo 4
}
\end{lstlisting}

O \textit{tipo 1} é usado quando não se sabe qual valor será alocado para a variável, enquanto o \textit{tipo 2} é uma maneira mais sucinta exclusiva do Go que força o tipo da variável de acordo com o valor recebido (note que o tipo não foi declarado). É importante considerar que o compilador só obtem sucesso em sua execução quando todas as variáveis instanciadas são devidamente usadas. Outros tipos de declaração são os tipos 3 e 4. Entre os tipos de variáveis suportados por Go estão \textbf{\textit{bool}}, \textbf{\textit{int}} \textit{(8, 16, 32, 64)}, \textbf{\textit{float}} \textit{(32, 64)}, \textbf{\textit{string}}, \textbf{\textit{byte}}, \textbf{\textit{rune}} e \textbf{\textit{complex}} \textit{(64, 128)}.

\subsubsection{Entrada e saída com fmt}
\label{secaodeio}

Com o pacote \texttt{fmt} é possível interagir com o usuário em modo texto no estilo \textit{input/output}. As funções principais de \texttt{fmt} tem por finalidade a entrada e saída de valores. O código abaixo mostra as funções de saídas mais comuns:

\begin{lstlisting}
package main

import "fmt"

func main() {
	str := "Gopher"
	
	fmt.Print("Ola ", str, "\n")
	fmt.Println("Ola", str)
	fmt.Printf("Ola %s\n", str)
}
\end{lstlisting}

As variações da função de impressão acima exibem a mesma saída:

\noindent\texttt{Ola Gopher}\\
\texttt{Ola Gopher}\\
\texttt{Ola Gopher}\\

Para receber uma entrada de valor, o pacote \texttt{fmt} nos disponibiliza a funcão \texttt{Scan()}. A leitura de um valor para uma variável é estabelecido colocando a variável precedida do caractere \& entre os parênteses de \texttt{Scan()}. Como exemplo temos:

\begin{lstlisting}
var variavel string
fmt.Scan(&variavel)
\end{lstlisting}


\subsection{Estrutura de seleção if/else}

A estrutura de seleção \textit{if/else} tem a função básica de tomar decisões perante a execução de um programa. Em Go este tipo de estrutura difere em relação a outras linguagens, ela só recebe valores lógicos verdadeiro ou falso. Isso influencia definitivamente a tipagem da variável que o comando vai receber, ou seja, as expressões necessitam ser do tipo \texttt{bool}. O código abaixo representa um modelo de uso do \textit{if/else}:

\begin{lstlisting}
idade := 22

if idade <= 18 {
	fmt.Println("Menor ou igual a 18 anos")
} else if idade > 25 {
	fmt.Println("Maior que 20 anos")
} else {
	fmt.Println("Entre 19 e 25 anos")
}
\end{lstlisting}

\subsection{Switch case}

A estrutura \textit{switch case} tem funcionalidade parecida com o \textit{if/else} visto na subseção anterior. Dependendo do caso, o \textit{switch case} pode se adequar melhor ao programa, especialmente em casos de Menus e estruturas de decisões com muitas opções. O \textit{switch case} é orientado a casos tendo o \textit{default} como caso escolhido quando nenhum dos outros forem satisfeitos. A sintaxe do \textit{switch case} segue o seguinte modelo:
	
\begin{lstlisting}
t := time.Now()

switch {
case t.Hour() < 12:
   	fmt.Println("Bom dia!")
case t.Hour() < 17:
   	fmt.Println("Boa tarde.")
default:
   	fmt.Println("Boa noite.")
}
\end{lstlisting}

\section{Coleções de dados}

As coleções de dados são tipos de variáveis especiais que podem serem entendidas como um conjunto ou listas de outras variáveis ou valores. Assim como em outras linguagens -- como a linguagem C com seus vetores -- as coleções de dados são geralmente uma sequencia de valores encadeados em ordem predefinida ou até mesmo apenas espaços separados não alocados para que depois venham ser preenchidos.


Em Go os padrões para listas de dados são dois: \textit{arrays} e \textit{slices}. A grande diferença entre eles está relacionada ao espaço de alocação de mémoria. Os \textit{arrays} são instâcias com tamanho fixo, já os \textit{slices} são uma camada abstraída dos \textit{arrays} que podem ser alocados dinamicamente permitindo crescer de forma indefinida sendo mais flexíveis.

\subsection{Arrays}

Os \textit{Arrays} são listas com valores do mesmo tipo, sendo que cada valor possui um índice que indica a posição dentro da lista. A contagem dos índices são delimitados pelo tamanho do \textit{array} que deve ser fixo e invariável. O primeiro elemento do \textit{array} possui índice 0, e o último elemento é sempre \texttt{len(array) - 1}. Podemos declarar um \textit{array} em Go utilizando as seguintes formas:

\begin{lstlisting}
var lista [3]int
pares := [3]int{2,4,6}
impares := [...]int{3, 5, 7}
nomes := [2]string{}

fmt.Println(colecao, pares, impares, nomes)
\end{lstlisting}

A saída para o código acima é: \texttt{[0 0 0] [2 4 6] [3 5 7] [ ]}.

O tamanho de um \textit{array} sempre deve ser especificado na sua declaração, como por exemplo o \textit{array} \texttt{lista} que foi fixado em \texttt{[3]int}, ou seja , seu tamanho é de 3 posições inteiras. Podemos notar que para ele a saida foi \texttt{[0 0 0]}, isso ocorre por que em Go quando se é declarado um \textit{array} sem valores definidos, estes assumem automaticamente valor zero. Para vetores de outra tipagem esse valor atribuído automaticamente pode ser gerado com outras representações:

\begin{itemize}
\item \textit{bool}: \texttt{false}, valor booleano falso;
\item \textit{int}: \texttt{0};
\item \textit{float}: \texttt{0.0};
\item \textit{strings}: \texttt{""};
\item ponteiros, funções, \textit{interfaces}, \textit{slices}, \textit{maps} e \textit{channels}: \texttt{nil}.
\end{itemize}


Existe também a possibilidade de criar \textit{arrays} multidimensionais em que os valores são \textit{arrays} dentro de \textit{arrays}. Declaramos eles da seguinte forma:


\begin{lstlisting}
var matrizA [2][2]int

matrizA[0][0], matrizA[0][1] = 7, 2
matrizA[1][0], matrizA[1][1] = 100, 90

matrizB := [2][2]int{{3, 2}, {-80, -1}}

fmt.Println("Matriz A:", matrizA)
fmt.Println("Matriz B:", matrizB)
\end{lstlisting}

A saída para o código acima é:

\noindent\texttt{Matriz A: [[7 2] [100 90]]}\\
\texttt{Matriz B: [[3 2] [-80 -1]]}

Como já foi mencionado, os \textit{arrays} não são tão flexíveis como os \texttt{slices} -- explicados na próxima subseção --, porém eles em sua importância dentro da linguagem Go. Cabe ressaltar que é possível trabalhar com \textit{arrays} de forma que eles sejam dinâmicos, porém requer um esforço manual custoso demais tendo que verificar seus limites e criação de \textit{arrays} para cópias de valores, o que possivelmente deixará o código mais poluído.

\subsection{Slices}

Os \textit{slices} são uma abstração que se baseiam em \textit{arrays} para possibilitar mais flexibilidade na coleção de dados encadeados. A principal característica de um \textit{slice} é a ausência de limites permitindo maior dinamicidade para a coleção de dados. Para declarar uma \textit{slice} podemos utilizar quase a mesma sintaxe de um \textit{array}. A diferença é que não especificamos seu tamanho:


\begin{lstlisting}
var sliceA []int
sliceB := []int{10, 20, 30}
SliceC := []string{}

fmt.Println(sliceA, sliceB, sliceC)
\end{lstlisting}

A saída para o código acima é: \texttt{[] [2 4 6] []}

É possível também criar um \textit{slice} com a função \texttt{make()}, que separa internamente um espaço de memória para um \textit{array} retornando uma referência para o \textit{slice}. Sua sintaxe pode ser escrita da seguinte forma:

\begin{lstlisting}
lista := make([]int, 10)
lista2 := make([]int, 10, 30)

fmt.Println(lista, len(lista), cap(lista))
fmt.Println(lista2, len(lista2),cap(lista2))
\end{lstlisting}

A saída deste código é:

\noindent\texttt{[0 0 0 0 0 0 0 0 0 0] 10 10}\\
\texttt{[0 0 0 0 0 0 0 0 0 0] 10 30}

O primeiro parâmetro da função \texttt{make()} indica o tipo dos elementos que irão ser criados, o segundo representa o tamanho inicial e o terceiro define a capacidade total de memória reservada. No \textit{slice} definido em \texttt{lista} é possível analisar que o tamanho inicial e capacidade total são os mesmos pelo fato do limite não ter sido definido, enquanto que em \texttt{lista2}, a capacidade é definida para um total de 30 posições.

\subsection{Maps}

Os \textit{maps} são uma estrutura de conjunto de dados organizado em \textbf{chave-valor}. Em outras linguagens como Ruby e Python, os \textit{maps} se assemelham aos \textit{Dict's} e \textit{Hashes} respectivamente. Podemos declarar um \textit{map} em Go usando a forma de declaração simples ou usando a função \texttt{make()}, assim como nos exemplos usados para os \textit{slices}. No exemplo a seguir temos declarados \textit{maps} com chaves do tipo \textit{int} e valores \textit{strings}.

\begin{lstlisting}
map1 := map[int]string{}
map2 := make(map[int]string)
\end{lstlisting}

Automaticamente os \textit{maps} tem tamanho indefinido. Porém é possível alocar a quantidade de espaços necessários possíveis durante a execução do programa tornando mais eficiente e fácil de se trabalhar com dados diferentes sem a necessidade de saber tamanhos predefinidos. Recomenda-se sempre definir uma especificação de memória passando um segundo argumento à função \texttt{make()}:   

\begin{lstlisting}
map3 := make(map[int]string, 2066)
\end{lstlisting}
As formas literais de inserir dados em um \textit{map} seguem a seguinte abordagem:


\begin{lstlisting}
timesDoPiaui := map[string]string{
	"RIV": "River",
	"PAR": "Parnahyba Sport Club",
	"PEC": "Sociedade Esportiva de Picos",
}
timesDoPiaui["PEC"] = "Piaui Esporte Clube"

fmt.Println(timesDoPiaui)
\end{lstlisting}

O resultado do código acima é:

\noindent\texttt{map[SEP:Sociedade Esportiva de Picos PEC:Piaui Esporte Clube RIV:River PAR:Parnahyba Sport Club]}

Podemos notar que na primeira indicação da chave \texttt{"PEC"} o valor especificado foi \texttt{Sociedade Esportiva de Picos}, e logo após foi escrito o seguinte código: \texttt{timesDoPiaui["PEC"] = "Piaui Esporte Clube"}, ele permite que os valores sejam atualizados diretamente no em uma chave especifica de um \textit{map}. Logo após a saída o valor que antes era \texttt{Sociedade Esportiva Picos} foi trocado por \texttt{"Piaui Esporte Clube"}.
\subsection{Loops}

A estrutura básica de repetição em Go é o comando \textit{for}. Ele é comumente usado para fazer iterações com listas, \textit{slice}, \textit{maps} e outros objetos iteráveis. Em sua forma mais comum é especificado uma condição lógica e o bloco código se repetirá até que a condição seja satisfeita com verdadeiro:

\begin{lstlisting}
valor1, valor2 := 0, 20

for valor1 < valor2 {
	valor1 += 1
}
\end{lstlisting}

O código acima será repetido em 20 iterações, ou seja, a variável \texttt{valor1} que recebe \texttt{0} na primeira linha será incrementado com mais um até que ele satisfaça a condição \textit{for} do \texttt{valor1} ser menor que o \texttt{valor2}. Há a possibilidade de fazer iterações da forma mais tradicional: 

\begin{lstlisting}
for i := 0; i < 10; i++ {
	...
}
\end{lstlisting}

O código acima também executa qualquer bloco de código até que a condição de verdadeiro seja satisfeita, então o comando fará 10 iterações. Outra forma de fazer uma iteração com \textit{for} sobre determinado objeto iterável é constituída com o auxilio do comando \texttt{range}:

\begin{lstlisting}
for indice, valor := range slice {
	...
}
\end{lstlisting}

No código acima é retornado o índice de cada elemento do \textit{slice}. Para obter acesso e modificar valores desse \textit{slice} podemos utilizar os índices. Dessa forma, basta omitir o segundo valor na atribuição e acessar cada elemento através de seu índice: 


\begin{lstlisting}
numeros := []int{1, 2, 3, 4, 5}

for i := range numeros {
	numeros[i] *= 2
}

fmt.Println(numeros)
\end{lstlisting}

A saída do código acima é: \texttt{[2 4 6 8 10]}.

Como último exemplo, podemos usar o laço \texttt{for} como um \textit{loop} infinito como o \textit{while} em outras linguagens:
\begin{lstlisting}
for {
	...
}
\end{lstlisting}
Para a parada do \textit{loop} basta instanciar algum comando de seleção como o \texttt{if} com \texttt{break} interno.

\section{Funções}

Um dos pontos fortes da linguagem Go é a variedade de formas em que podemos escrever funções. Go permite que suas funções possam receber parâmetros, assim como também retornar valores podendo ser múltiplos. Até este momento neste capítulo usamos funções, pois a rotina de um código em Go deve iniciar da função \texttt{main()}. Nas subseções seguintes detalhamos alguns dos tipos de funções mais usados.

\subsection{Funções básicas}

Em Go o padrão básico de declaração das funções se dá com a palavra \texttt{func} seguido do nome da função e dos possíveis valores de parâmetros. Um exemplo seria uma função que imprima uma simples frase:

\begin{lstlisting}
func imprimirString() {
	fmt.Println("Imprimindo uma frase")
}
\end{lstlisting}

Agora iremos passar alguns argumentos para esta função, fazendo que ela imprima um valor do tipo \textit{string} e outro do tipo \textit{int}:

\begin{lstlisting}
func imprimirString(nome string, idade int) {
	fmt.Printf("Ola, meu nome eh %s e eu tenho %d anos.\n",
	 nome, idade)
}
\end{lstlisting}

Caso os argumentos passados para a função sejam do mesmo tipo, é possível agrupá-los em uma única especificação:

\begin{lstlisting}
func intervalo(x, y int) {
	for i := x; i < y; i++ {
		fmt.Printf("%d ", i)
	}
}
\end{lstlisting}

Para retornar valores em uma função é necessário definir seu tipo logo após a passagem de parâmetros. Além disso, também é necessário fazer o uso do \texttt{return}:

\begin{lstlisting}
func simplesSoma(x, y int) int {
	return x + y
}
\end{lstlisting}

O retorno de funções em Go também podem retornar vários valores. Para que isso seja possível devemos adicionar os tipos retornados na sequencia correta entre parênteses. O \texttt{return} também deve estar de acordo:

\begin{lstlisting}
func sucessorEAntecessor(x int) (int, int) {
	return x + 1, x - 1
}
\end{lstlisting}

\subsection{Retorno definido}

Em Go é possível definir a variável de retorno de uma função logo na declaração. Para que isso seja possível devemos usar a mesma variável de retorno definida para receber um valor dentro da função e ainda usar o \texttt{return} sem especificar valores:

\begin{lstlisting}
func simplesSoma(x, y int) (soma int) {
	soma = x + y
	return
}
\end{lstlisting}

\subsection{Funções de argumentos variáveis}

As funções de argumentos variáveis recebem como argumento um determinado tipo e uma variável especificada. A ideia é permitir que sejam passados \textit{n} argumentos para este tipo de função para que trate esses valores como uma lista. Podemos assim iterá-los como um \textit{array}:

\begin{lstlisting}
func numeros(lista ...int) {
	for _, numero := range lista {
		fmt.Println(numero)
	}
}
\end{lstlisting}

\subsection{Funções anônimas}

Funções anônimas são funções que são criadas no momento em que são utilizadas. Elas são alocadas para uma variável e são usadas com frequência quando se quer resolver pequenos problemas. Por exemplo, podemos declarar uma função anônima para deixar todas as letras de uma \textit{string} em maiúsculo. Para o próximo código importamos o pacote \texttt{strings}. Veja o exemplo:

\begin{lstlisting}
func main() {
	maiusculo := func(str string) string {
		return strings.ToUpper(str)
	}
	
	nome := "Diego Fernando"
	
	fmt.Println(nome)
	fmt.Println(maiusculo(nome))
}
\end{lstlisting}

A saída deste código é:

\noindent\texttt{Diego Fernando}\\
\texttt{DIEGO FERNANDO}\\

\subsection{Defer}
\label{defer}

O \texttt{defer} define uma função que sempre será executada ao fim de uma rotina atual. O comando é ideal para programas em que se usa I/O onde deve haver abertura e fechamento de arquivos ou conexões, pois garante a execução de determinada função ao final. O exemplo a seguir apresenta a função \texttt{defer} que imprime a \textit{string} \texttt{Segunda acao} logo após a impressão de \texttt{Primeira acao}:

\begin{lstlisting}
func main() {
	defer func() {
		fmt.Println("Segunda acao")
	}()
	
	fmt.Println("Primeira acao")
}
\end{lstlisting}

\section{Tipos de dados}
	
Além dos tipos de dados tradicionais, Go permite a criação de tipos personalizados de dados. Este tipo de característica se torna importante, uma vez que recursos relativos a Orientação a Objetos praticamente não existem em \textit{Golang}. Apesar desse ponto, Go compensa o uso da OO com recursos como funções que se estendem de tipos e \textit{interfaces}, que estão apresentados nesta seção.
	
\subsection{Criando novos tipos}
	
Para criar um novo tipo de dado basta acrescentar \texttt{type} antes de qualquer tipo primitivo. Com a finalidade de ilustrar a criação de um novo tipo de dado, no código abaixo é declarado o tipo de dado \texttt{TimesDoPiaui} baseado em um \textit{slice} do tipo primitivo \textit{string}. Note que, tanto a instância, como a recepção dos valores são feitos de fato dentro da função \texttt{main()}.
	
\begin{lstlisting}
package main

import "fmt"

type TimesDoPiaui []string

func main() {	
  times := make(TimesDoPiaui, 4)
  times[0] = "River"
  times[1] = "Parnahyba Sport Club"
  times[2] = "Sociedade Esportiva de Picos"
  times[3] = "Piaui Esporte Clube"

  for i := 0; i < len(times); i++ {
  	fmt.Println(times[i])
  }	
}

\end{lstlisting}

	Á primeira vista, esta estrutura pode não fazer muito sentido. Porém a grande vantagem em usar tipos customizados é a possibilidade de estendê-lo. Usaremos como exemplo uma função que mostre se o time "Parnahyba Sport Club" está no \textit{slice}. Observe que não passamos nenhum parâmetro, porém o Go entende que esta função é do tipo \texttt{TimesDoPiaui} e a trata como um "método" para este tipo.
	
\begin{lstlisting}
func (time TimesDoPiaui) TemPhb() {
  for _, value := range time {
    if value == "Parnahyba Sport Club" {
       	fmt.Println("Tem Parnahyba Sport Club!")
    }
  }
}
\end{lstlisting}
	
\subsection{Structs}

As \textit{structs} ou tipos estruturados de dados seguem um princípio de criar tipos a partir de conjuntos de outros tipos. É uma abstração muito utilizada em linguagens como C e C++. \textit{Structs} facilitam o agrupamento de dados criando a noção de registros. Com fim de demonstrar um exemplo de \textit{struct}, usaremos o mesmo tema da seção anterior onde será  um tipo estruturado de nome \texttt{TimeDoPiaui} onde teremos o atributos \texttt{nome}, \texttt{n\_vitorias}, \texttt{n\_derrotas} e \texttt{classificado}.
	
\begin{lstlisting}
package main

import "fmt"

type TimeDoPiaui struct {
	nome         string
	n_vitorias   int
	n_derrotas   int
	classificado bool
}

func main() {
	river := TimeDoPiaui{
		nome:         "River",
		n_vitorias:   23,
		n_derrotas:   6,
		classificado: true,
	}

	fmt.Println(river)
}

\end{lstlisting}

A saída do código acima é: \texttt{{River 23 6 true}}. Podemos fazer uma função que estende do tipo \texttt{TimeDoPiaui} e que imprima dados relativos ao time. Isso trará mais possibilidades de reúso de código. Considerando a \textit{struct} criada, instanciamos mais outro time e criamos a função \texttt{MostraSituação()}:

\begin{lstlisting}
func main() {
	river := TimeDoPiaui{
		nome:         "River",
		n_vitorias:   23,
		n_derrotas:   7,
		classificado: true,
	}

	picos := TimeDoPiaui{
		nome:         "SEP",
		n_vitorias:   18,
		n_derrotas:   12,
		classificado: false,
	}

	river.MostraSituacao()
	picos.MostraSituacao()
}

func (t TimeDoPiaui) MostraSituacao() {
	situacao := "nao esta"
	if t.classificado {
		situacao = "esta"
	}
	
	fmt.Printf("%s tem %d vitorias,"+
			   " %d derrotas e %s "+
		   	   "classificado.\n", t.nome,
								  t.n_vitorias,
								  t.n_derrotas,
								  situacao)
}

\end{lstlisting}

O resultado desta estrutura é:

\noindent\texttt{River tem 23 vitórias, 7 derrotas e está classificado.}\\
\texttt{SEP tem 18 vitórias, 12 derrotas e não está classificado.}

\subsubsection{Manipulação de tipos de dados}

Vimos na subseção anterior que podemos criar estruturas e interagir com elas por meio de funções. Porém, a função \texttt{MostraSituação()} apenas faz uma exibição de valores. Nesta seção evoluiremos a estrutura da seção anterior criando um \textit{slice} para o tipo \texttt{TimeDoPiaui} com as funções \texttt{AdicionarTime()}, \texttt{RetirarTime()} e \texttt{Mostrar\\Times()}. 

É válido ressaltar que, assim como nas linguagens C e C++, Go usa ponteiros. Em tipos estruturados, os ponteiros são necessários caso quisermos alterar elementos de estruturas. Portanto para o exemplo projetado usaremos ponteiros nas funções de \texttt{AdicionarTime()} e \texttt{RetirarTime()}, deste modo poderemos modificar a lista de objetos.

Na mesma seção do código em que se encontra o \texttt{type TimeDoPiaui struct}, incluiremos outro tipo que será um \textit{slice}. Algo como:

\begin{lstlisting}
type TimeDoPiaui struct {
	nome         string
	n_vitorias   int
	n_derrotas   int
	classificado bool
}

type Times []TimeDoPiaui
\end{lstlisting}

Como a manipulação é feita no tipo \texttt{Times}, então as funções são estendidas neste tipo. Na funções de adição e remoção usamos o comando \texttt{append()} para fazer recriações modificadas do \textit{slice} original. As funções ficam organizada deste modo:

\begin{lstlisting}
func (t *Times) AdiconarTime(nome string,
							 n_vitorias int,
							 n_derrotas int,
							 classificado bool) {
	novoTime := TimeDoPiaui{
		nome,
		n_vitorias,
		n_derrotas,
		classificado,
	}

	*t = append(*t, novoTime)
	fmt.Printf("\n%s adicionado!", nome)
}

func (t *Times) RetirarTime(indice int) {
	times := *t
	time_retirado := times[indice]
	*t = append(times[0:indice], times[indice+1:]...)
	fmt.Printf("\n%s removido!", time_retirado.nome)
}

func (t Times) MostrarTimes() {
	fmt.Println("\n\n**Times:**")
	for i := 0; i < len(t); i++ {
		fmt.Printf("%s, %d, %d, %t\n", t[i].nome,
									   t[i].n_vitorias,
									   t[i].n_derrotas,
									   t[i].classificado)
	}
}
\end{lstlisting}

Com essa estrutura, podemos deixar a função \texttt{main()} mais limpa, assim deixando apenas chamadas de funções nela, veja um exemplo:

\begin{lstlisting}
func main() {
	times := Times{}
	times.AdiconarTime("River", 23, 7, true)
	times.AdiconarTime("Parnahyba Sport Club", 25, 5, true)
	times.AdiconarTime("SEP", 20, 10, false)
	times.MostrarTimes()
	times.RetirarTime(0)
	times.MostrarTimes()
}
\end{lstlisting}

A saída do código criado seria algo como:

\noindent\texttt{River adicionado!}\\
\texttt{Parnahyba Sport Club adicionado!}\\
\texttt{SEP adicionado!}\\ \\
\texttt{**Times:**}\\
\texttt{River, 23, 7, true}\\
\texttt{Parnahyba Sport Club, 25, 5, true}\\
\texttt{SEP, 20, 10, false}\\ \\
\texttt{River removido}!\\ \\
\texttt{**Times:**}\\
\texttt{Parnahyba Sport Club, 25, 5, true}\\
\texttt{SEP, 20, 10, false}\\

\subsubsection{Interfaces}

A melhor definição para \textit{interfaces} é que elas são um "contrato" para outros tipos de dados. Com \textit{interfaces} é possível criar conjuntos de métodos que servem para \textit{n} tipos estruturados, pois ele consegue orientar uma mesma ação para tipos diferentes de dados, mesmo que permitindo que o tipo possa ser direcionado a um método apropriado.

Vamos a um exemplo hipotético imaginando duas \textit{structs}: \texttt{TimeFutebol} e \texttt{TimeBasquete}. Apesar de serem tipos diferentes, as duas tem métodos estendidos com a mesma finalidade que serve para fazer o calculo de pontos do time em determinado campeonato baseado na quantidade de vitórias. Definimos regras de negócios diferentes para basquete e futebol, onde, para o basquete cada vitória vale 2 pontos e para o futebol cada vitória vale 3:

\begin{lstlisting}
type TimeFutebol struct {
	n_vitorias int
}

type TimeBasquete struct {
	n_vitorias int
}

func (t TimeFutebol) PontosEmVitorias() int {
	return t.n_vitorias * 3
}

func (b TimeBasquete) PontosEmVitorias() int {
	return b.n_vitorias * 2
}
\end{lstlisting}

Após declarados os tipos estruturados, iremos escrever mais um tipo \textit{interface} e um método estendido do tipo \textit{interface} recém criado:

\begin{lstlisting}
type Time interface {
	PontosEmVitorias() int
}

func Pontos(t Time) int {
	return t.PontosEmVitorias()
}
\end{lstlisting}

A função \texttt{Pontos()} recebe como parâmetro uma \textit{interface} podendo ser um tipo \texttt{TimeFutebol} ou \texttt{TimeBasquete}. Já o retorno da função \texttt{Pontos()} é a chamada do método \texttt{PontosEmVitorias()} em que foram feitas uma implementação para cada tipo. Dependendo do tipo recebido a função \texttt{Pontos()} irá direcionar a chamada para o método \texttt{PontosEmVitorias()} adequado.

A mágica acontece quando usamos o mesmo método para os dois tipos. Vejamos como fica a função \texttt{main()}:

\begin{lstlisting}
func main() {
	time_futebol := TimeFutebol{20}
	time_basquete := TimeBasquete{20}
	
	fmt.Println(Pontos(time_futebol))
	fmt.Println(Pontos(time_basquete))
}
\end{lstlisting}

\label{duck}

Nas instâncias acima, \texttt{time\_futebol} e \texttt{time\_basquete} tem a mesma quantidade de vitórias (20), porém se executarmos essa função teremos a saída \texttt{60 40}, ou seja 60 pontos para o time de futebol e 40 pontos para o time de basquete.



\section{Tratamento de erros}

O Go permite que funções retornem múltiplos valores, tal característica favorece o tratamento de erros. Existem divergências de opiniões com relação ao tratamento de erros em Go, algumas delas estão ligadas a adaptação a forma que é feita. Por outro lado também há quem diga que é uma maneira simples e elegante para tratar de exceções. Observe o exemplo a seguir:

\begin{lstlisting}
func Par(numero int) (bool, error) {
    if numero <  0 {
	return false, errors.New("Numero Invalido!")
    }
    if numero % 2 == 0 {
        return true, nil
    }
    return false, nil
}
\end{lstlisting}


Podemos observar que a função leva um parâmetro \textit{int} em seu escopo, ela verifica se o número é par ou ímpar. Como retorno ela envia para a função principal \texttt{(bool, error)}, ou seja, um parâmetro de resposta correta ou errada se é um par ou ímpar consecutivamente e um valor de erro de função. 


Caso seja passado um número abaixo de \texttt{0} ela entrará no primeiro \texttt{if} e retornará um \texttt{false, err}. Se for ímpar ela passará do primeiro e segundo \texttt{if} e retornara \texttt{false}. Por último, caso entre no segundo \texttt{if} ela retorna \texttt{true} e om valor de erro \texttt{nil}.

%Essa forma de tratamento de erros é muito mais simples de se entender; diferentemente em outras linguagens como o  Java, que fazendo necessário a exportação de várias bibliotecas e uma série de encapsulamentos com seus seus \textit{try} e \textit{catch} para tratar os erros, que de certa forma só deixam o código poluído.

\section{Concorrência}

\label{concorrencia}

Todas as Linguagens de Programação tem foco em determinada resolução de problema. Com Go não é diferente. Um dos pontos fortes da linguagem é a forma com que ela lida com a programação concorrente. As \textit{goroutines}, por exemplo, demostram que não há dificuldade na implementação de processos independentes. As seguintes subseções apresentam os elementos básicos da concorrência na linguagem Go.

\subsection{Goroutines}

As \textit{goroutines} são similares as \textit{threads} comuns, porém elas são gerenciadas pelo ambiente de execução, ou seja, a linguagem decide quando elas iram ser interligadas as \textit{threads} principais do sistema. Por esse fator elas se tornam extremamente leves por ter um controle sobre qual execução realmente é necessária estar sendo executada pelo Sistema Operacional.

Para dar início a uma \textit{goroutine} se utiliza uma palavra-chave \texttt{go} antes da chamada da função. Isso permite que a execução do processo principal rode em parelelo a função sem a necessidade de bloquear principal uma delas. A seguir a função \texttt{sequencia()} recebe um número inteiro e imprime uma sequencia que vai do 0 até o valor passado como argumento:

\begin{lstlisting}
func sequencia(n int) {
	for i := 0; i < n; i++ {
		fmt.Printf("%d ", i+1)
		time.Sleep(200 * time.Millisecond)
	}
	fmt.Printf(" ...Sequencia de %d terminou... ", n)
}
\end{lstlisting}

O código a seguir chama a função \texttt{sequencia()} instanciada duas vezes com números diferentes:

\begin{lstlisting}
func main() {
	sequencia(5)
	sequencia(10)
}
\end{lstlisting}

Ao executar a função \texttt{main()} a saida do código é:

\noindent\texttt{1 2 3 4 5  ...Sequencia de 5 terminou... 1 2 3 4 5 6 7 8 9 10  ...Sequencia de 10 terminou...}

Agora façamos diferente, vamos usar a palavra-chave \texttt{go} para um das chamadas da funções:

\begin{lstlisting}
func main() {
	go sequencia(5)
	sequencia(10)
}
\end{lstlisting}

Logo a saida da função \texttt{main()} será: 

\noindent\texttt{1 1 2 2 3 3 4 4 5 5 6  ...Sequencia de 5 terminou... 7 8 9 10  ...Sequencia de 10 terminou...}. 

Notamos que já ocorreu uma diferença entre as saídas. A \textit{goroutine} aberta para a função imprimir foi executada em paralelo a função principal. Isso torna o programa mais eficiente em recursos.

\subsection{Waitgroups}

Usando o mesmo exemplo da subseção anterior, façamos o seguinte experimento: ao invés de acionar a \textit{goroutine} levando o valor 5 como argumento, iremos então inverter os valores das suas funções \texttt{sequencia()}, que agora contará com os valores 10 e 5, respectivamente. O escopo da função \texttt{main()} agora é este: 

\begin{lstlisting}
func main() {
	go sequencia(10)
	sequencia(5)
}
\end{lstlisting}

Agora executando o código com os valores invertidos, temos: 

\noindent\texttt{1 1 2 2 3 3 4 4 5 5  ...Sequencia de 5 terminou...}

Analisando a saída, percebemos que o paralelismo houve até a rotina principal terminar. Isso quer dizer que não houve continuidade da \textit{goroutine} da função \texttt{sequencia(10)}. Este comportamento acontece porque Go entende que as \textit{goroutines} devem respeitar o tempo de execução da rotina principal, ou seja, o processo \texttt{main()}. Para o processo principal esperar o termino de todos os processos em paralelo, se faz necessário o uso de \textit{waitgroups}.

Modificaremos o código adequando-o para \textit{waitgroups}. O primeiro passo deve ser adicionar o pacote \texttt{sync} dentro das importações para utilizarmos seus módulos. Devemos também instanciar uma variável global do tipo \texttt{sync.WaitGroup}. Faremos então \texttt{var group sync.WaitGroup}. Reescreveremos a função \texttt{main()} com o uso de \texttt{group} previamente instanciada. Fica dessa maneira:

\begin{lstlisting}
func main() {
	group.Add(1)
	go sequencia(10)
	sequencia(5)
	group.Wait()
}
\end{lstlisting}

A função \texttt{group.Add()} especifica previamente quantos processos o programa deve esperar para poder ser finalizado. Ao final das chamadas das funções usamos o \texttt{group.Wait()}, que tem por finalidade permitir o processo principal esperar todas os processos do grupo terminarem sua execução. Também teremos algumas modificações na função \texttt{sequencia()}:

\begin{lstlisting}
func sequencia(n int) {
	defer group.Done()
	for i := 0; i < n; i++ {
		fmt.Printf("%d ", i+1)
		time.Sleep(200 * time.Millisecond)
	}
	fmt.Printf(" ...Sequencia de %d terminou... ", n)
}
\end{lstlisting}

Fizemos o uso do \texttt{defer} -- explicado na seção \ref{defer} -- para assegurar que a função \texttt{group.Done()} seja executada ao fim da função \texttt{sequencia()}. Basicamente, \texttt{group.Done()} tem por finalidade "avisar" o processo principal que a atual rotina terminou e que o programa não precisa mais esperar por ela. Isso resolve o problema descrido no início desta subseção.

\subsection{Channels}
As \textit{goroutines} ultilizam de uma melhor abordagem em alta performance e eficiência no uso de recursos de processamento. Porém a capacidade de executar diferentes \textit{goroutines} concorrentes pode ser uma situação muito complicada porque geralmente irá se fazer a necessidade de fazer comunicações entre elas.

Os \textit{channels} são responsáveis por abstrair essa comunicação. Ou seja, eles abrem um canal para servir de ponte e conduzir as informações de qualquer tipagem em Go. A função \texttt{make()} é responsável de criar um canal para trafegar os valores. Vamos ao seguinte exemplo com um tipo \textit{int}. Depois Utilizamos o operador \texttt{<-} -- \textit{arrow operator} ou operador seta -- para interagir com o cana criado. A seta permite a direção correta do fluxo da comunicação, vamos enviar valores \textit{int} para o canal \texttt{ch}:

\begin{lstlisting}
ch := make(chan int)
ch <- 33
\end{lstlisting}


Podemos obter o valor enviado para o canal \texttt{c} da seguinte forma:

\begin{lstlisting}
valor := <-c
\end{lstlisting}

A seguir está um exemplo mais completo para maior entendimento da real função dos \textit{channels}:

\begin{lstlisting}
func main() {
	ch := make(chan int)
	go induzir(ch)
	recebido := <-ch
	fmt.Println(recebido)
}

func induzir(ch chan int) {
	ch <- 33
}
\end{lstlisting}

Notamos que inicialmente instaciamos um canal \texttt{ch} que conduz informações do tipo \textit{int} e logo após passamos para esse canal um valor inteiro por meio do disparo da \textit{goroutine} \texttt{induzir()}. Isso bloqueia qualquer outra operação com o mesmo canal até que a outra seja completada; permitindo uma sincronização automática entre as \textit{goroutines} sem mecanismos para travá-las. A variável \texttt{recebido} receberá o valor trafegado antes pela função \texttt{induzir()}, que em seguida é impresso com valor 33.
\section{Pacotes Go}

A modularizarão do código permite ao desenvolvedor uma série de benefícios. A importância de um projeto bem organizado reflete no tanto no poder de manutenção do código, como na sua abstração. Para que esta característica se concretize, existem na maioria das Linguagens de Programação a possibilidade da associação entre arquivos de uma mesma pasta, ou até mesmo a criação de novos módulos. No Go esses módulos são chamados de pacotes (\textit{packages}). Abordaremos sua utilização nas seguintes subseções.

\subsection{Criando um pacote Go}

Se observarmos bem, desde o nosso primeiro exemplo -- \textit{hello.go} -- deste capítulo, fizemos o uso de pacotes. Geralmente, a primeira linha de qualquer código Go contém a declaração do pacote que representa o resto do código. Quando usamos a função \texttt{fmt.Println()} também fazemos uma importação de um pacote. Neste caso importamos o pacote \texttt{fmt}, que faz parte da biblioteca nativa do Go.

Para efetuar a criação de um pacote, primeiro devemos definir uma pasta para o nosso projeto dentro de \texttt{GOPATH/src}. Com fim de exemplificar um modelo de estrutura, criaremos um pacote chamado "\textit{meu-projeto}" contendo um arquivo "\textit{main.go}" e dentro do arquivo "\textit{main.go}", teremos a seguinte estrutura:

\begin{lstlisting}
package main

import (
	"fmt"
)

func main() {
	
}
\end{lstlisting}

Vamos agora construir nosso pacote criando outra pasta dentro de "\textit{meu-projeto}". Para este caso, a denominaremos como "\textit{operacoes}". Dentro da pasta criaremos um arquivo Go chamado "\textit{matematica.go}" e nele vamos fazer duas funções: uma de soma de dois números inteiros e outra para subtração desses números. O conteúdo seguirá a representação abaixo:

\begin{lstlisting}
package operacoes

func Soma(x, y int) int {
	return x + y
}

func Subtracao(x, y int) int {
	return x - y
}
\end{lstlisting}

Note que denominamos o nome do pacote logo no início com o \texttt{package opera\\coes}. Este pacote atenderá por este nome quando for chamado externamente. As funções de um pacote obrigatoriamente devem iniciar com letra maiúscula, pois esta característica as deixam acessíveis fora do próprio arquivo. Voltaremos então para o arquivo \textit{main.go} onde já foi desenvolvida uma estrutura inicial. Agora podemos fazer a importação e a utilização das funções do pacote recém-criado:

\begin{lstlisting}
package main

import (
	"fmt"
	"meu-projeto/operacoes"
)

func main() {
	fmt.Println(operacoes.Soma(10, 3))
	fmt.Println(operacoes.Subtracao(10, 3))
}
\end{lstlisting}

Observe que a importação de um pacote segue o modelo da representação de um caminho ou diretório. Desta forma, é possível importar pacotes em qualquer circunstância desde de que criados dentro da pasta \texttt{GOPATH/src}.

\subsection{Pacotes externos}

Através de comandos via terminal, também é possível fazer uso de pacotes externos em Go. O comando que executa esta ação é o \texttt{go get}. Para demonstrar sua aplicação, foi criado um pacote chamado \textit{distanceToEnucomp} disponível no GitHub\footnote{https://github.com/diegofsousa/distanceToEnucomp}. Basicamente, o pacote criado é composto por três funções:

\begin{itemize}
	\item \texttt{Info()}: Retorna uma \textit{string} com a descrição do evento;
	\item \texttt{ShortCourses()}: Retorna uma \textit{array} com os minicursos do evento;
	\item \texttt{distanceTo(lat, lon)}: Levando como parâmetros latitude e longitude, retorna o cálculo da distância em linha reta para o local onde ocorreu o evento.
\end{itemize}

O comando para efetuar o \textit{download} do pacote é:

\texttt{go get github.com/diegofsousa/distanceToEnucomp}

A importação e utilização do pacote segue o diretório onde foi instalado. O código abaixo exemplifica o uso das funções:

\begin{lstlisting}
package main

import (
	"fmt"
	"github.com/diegofsousa/distanceToEnucomp"
)

func main() {
	fmt.Println("Info do Evento:")
	fmt.Println(distanceToEnucomp.Info())
	
	fmt.Println("\nMinicursos do Evento:")
	for _, value := range distanceToEnucomp.ShortCourses() {
		fmt.Println(value)
	}
	
	fmt.Printf("\nA distancia ate o Evento eh de %f Km.\n",
	distanceToEnucomp.DistanceTo(-7.079602, -41.433254))
}
\end{lstlisting}

As dependências externas podem refletir significamente no projeto. Dependendo do caso, podem deixar o código mais enxuto. Porém, a linguagem Go é bem completa em relação aos seus módulos nativos, o que influencia na não utilização de pacotes de terceiros.

% you should really use BibTeX instead of this... :-)
\begin{thebibliography}{99}
	
\bibitem{codal} CODAL. (2016) ``Do You Need to Learn Google’s Programming Language?'', https://medium.com/@gocodal/do-you-need-to-learn-googles-programming-language-b7df74d6a06b, Outubro de 2017.

\bibitem{doxsey} Doxsey, C. ``Introdução à linguagem Go: Crie programas escaláveis e confiáveis'', Novatec Editora, 2016.
	
\bibitem{fi} Filipini, C. ``Programando Em Go: CRIE APLICAÇOES COM A 	LINGUAGEM DO GOOGLE'', https://books.google.com.br/books?id=fOA1vgAACAAJ,
	CASA DO CODIGO.	
	
\bibitem{marins} Marins, U. (2016) ``Por que utilizar Go/Golang no seu backend?'',
https://tableless.com.br/por-que-utilizar-gogolang-no-seu-backend/, Outubro de 2017.

\bibitem{patel} Patel, K. (2017) ``Why should you learn Go?'',
https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65, Outubro de 2017.

\bibitem{se} SEBESTA, Robert W. ``Conceitos de linguagens de programação``. Bookman Editora, 2009.

\bibitem{young} Youngman, N. (2012) ``Why Go?'',
https://nathany.com/why-go/, Outubro de 2017.

\end{thebibliography}

\end{document}
